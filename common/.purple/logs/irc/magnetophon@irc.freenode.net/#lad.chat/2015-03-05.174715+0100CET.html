<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>Conversation with #lad at Thu 05 Mar 2015 05:47:15 PM CET on magnetophon@irc.freenode.net (irc)</title></head><body><h3>Conversation with #lad at Thu 05 Mar 2015 05:47:15 PM CET on magnetophon@irc.freenode.net (irc)</h3>
<font size="2">(05:47:15 PM)</font><b> The topic for #lad is: Linux Audio Developers | Don&apos;t ask to ask, just ask | Lists: <a href="http://lists.linuxaudio.org">http://lists.linuxaudio.org</a> | Jack: <a href="http://jackaudio.org">http://jackaudio.org</a> | LV2: <a href="http://lv2plug.in">http://lv2plug.in</a></b><br/>
<font size="2">(05:47:15 PM)</font><b> Topic for #lad set by tapas!~tapas@static.231.2.63.178.clients.your-server.de at 10:37:26 AM on 05/13/2013</b><br/>
<font size="2">(06:06:35 PM)</font><b> edogawa_ is now known as edogawa</b><br/>
<font color="#A82F2F"><font size="2">(06:23:38 PM)</font> <b>falktx:</b></font> ok<br/>
<font color="#A82F2F"><font size="2">(06:23:56 PM)</font> <b>falktx:</b></font> errm, wrong channel... nvm me<br/>
<font color="#A82F2F"><font size="2">(06:54:24 PM)</font> <b>falktx:</b></font> more synths!<br/>
<font color="#A82F2F"><font size="2">(06:54:27 PM)</font> <b>falktx:</b></font> https://i.imgur.com/LktCz5J.png<br/>
<font size="2">(08:37:53 PM)</font><b> D-HUND is now known as debdog</b><br/>
<font color="#A82F2F"><font size="2">(10:13:41 PM)</font> <b>fps:</b></font> wrl: interesting.. i was thnking about usig a red-black tree or something similar to manage events at arbitrary times<br/>
<font color="#A82F2F"><font size="2">(10:13:58 PM)</font> <b>wrl:</b></font> fps: yeah you could do that really easily<br/>
<font color="#A82F2F"><font size="2">(10:14:02 PM)</font> <b>wrl:</b></font> iirc libuv does that for timers<br/>
<font color="#A82F2F"><font size="2">(10:14:06 PM)</font> <b>fps:</b></font> O(log n) lookup should be quick enough to do in every process cycle<br/>
<font color="#A82F2F"><font size="2">(10:14:12 PM)</font> <b>wrl:</b></font> yeah<br/>
<font color="#A82F2F"><font size="2">(10:14:17 PM)</font> <b>wrl:</b></font> that&apos;s the idea<br/>
<font color="#A82F2F"><font size="2">(10:14:30 PM)</font> <b>fps:</b></font> but i feared the amount of work.. :)<br/>
<font color="#A82F2F"><font size="2">(10:14:34 PM)</font> <b>fps:</b></font> and had other things to do<br/>
<font color="#A82F2F"><font size="2">(10:14:43 PM)</font> <b>fps:</b></font> your thing seems to aim in a similar direction?<br/>
<font color="#A82F2F"><font size="2">(10:14:48 PM)</font> <b>fps:</b></font> or did i misuderstand?<br/>
<font color="#A82F2F"><font size="2">(10:14:55 PM)</font> <b>wrl:</b></font> in a similar direction to what?<br/>
<font color="#A82F2F"><font size="2">(10:14:59 PM)</font> <b>fps:</b></font> 23:20 &lt; wrl&gt; fundamental: i think my next task is going to be implementing a ck_epoch based balanced search tree<br/>
<font color="#A82F2F"><font size="2">(10:15:11 PM)</font> <b>fps:</b></font> using a log n lookup structure for events?<br/>
<font color="#A82F2F"><font size="2">(10:15:19 PM)</font> <b>wrl:</b></font> well, for audio clips, roughly<br/>
<font color="#A82F2F"><font size="2">(10:15:38 PM)</font> <b>fps:</b></font> which can be placed at arbitrary times on the timeline, too, i suppose<br/>
<font color="#A82F2F"><font size="2">(10:15:42 PM)</font> <b>wrl:</b></font> yeah, exactly<br/>
<font color="#A82F2F"><font size="2">(10:15:45 PM)</font> <b>fps:</b></font> cool :)<br/>
<font color="#A82F2F"><font size="2">(10:15:45 PM)</font> <b>wrl:</b></font> what complicates things for me is the need to share the data structure from a non-audio thread to the audio thread<br/>
<font color="#A82F2F"><font size="2">(10:15:55 PM)</font> <b>wrl:</b></font> so that&apos;s why i&apos;m investigating this whole RCU approach<br/>
<font color="#A82F2F"><font size="2">(10:16:09 PM)</font> <b>fps:</b></font> yes, you want to modify it from the non - rt thread<br/>
<font color="#A82F2F"><font size="2">(10:16:18 PM)</font> <b>fps:</b></font> i suppose?<br/>
<font color="#A82F2F"><font size="2">(10:16:22 PM)</font> <b>wrl:</b></font> yes<br/>
<font color="#A82F2F"><font size="2">(10:16:26 PM)</font> <b>fps:</b></font> but the balancing can take quite a while<br/>
<font color="#A82F2F"><font size="2">(10:16:35 PM)</font> <b>fps:</b></font> so maybe pointer swap agai?<br/>
<font color="#A82F2F"><font size="2">(10:16:38 PM)</font> <b>fps:</b></font> n?<br/>
<font color="#A82F2F"><font size="2">(10:16:41 PM)</font> <b>wrl:</b></font> the non-rt thread will be the writer and the rt thread will be the reader<br/>
<font color="#A82F2F"><font size="2">(10:16:53 PM)</font> <b>wrl:</b></font> there&apos;s actually some published literature on this<br/>
<font color="#A82F2F"><font size="2">(10:16:58 PM)</font> <b>fps:</b></font> cool<br/>
<font color="#A82F2F"><font size="2">(10:17:01 PM)</font> <b>wrl:</b></font> http://www.pdx.edu/sites/www.pdx.edu.computer-science/files/tr1006.pdf<br/>
<font color="#A82F2F"><font size="2">(10:17:20 PM)</font> <b>fps:</b></font> cool, will read later :)<br/>
<font color="#A82F2F"><font size="2">(10:17:21 PM)</font> <b>fps:</b></font> ty<br/>
<font color="#A82F2F"><font size="2">(10:17:29 PM)</font> <b>wrl:</b></font> single-writer multiple-reader seems to be the way forward for me<br/>
<font color="#A82F2F"><font size="2">(10:17:39 PM)</font> <b>fps:</b></font> the introduction sounds promising already :)<br/>
<font color="#A82F2F"><font size="2">(10:17:52 PM)</font> <b>wrl:</b></font> yeah<br/>
<font color="#A82F2F"><font size="2">(10:18:04 PM)</font> <b>wrl:</b></font> i&apos;m going to do my best to release the tree code as open-source<br/>
<font color="#A82F2F"><font size="2">(10:18:21 PM)</font> <b>wrl:</b></font> will likely contribute it to the concurrencykit project since i&apos;m using a lot of their primitives<br/>
<font color="#A82F2F"><font size="2">(10:18:21 PM)</font> <b>fps:</b></font> maybe another way would be to do most of the heavy liftig of the balancing in the non rt thread<br/>
<font color="#A82F2F"><font size="2">(10:18:30 PM)</font> <b>fps:</b></font> and just send the resulting update operations to the rt thread<br/>
<font color="#A82F2F"><font size="2">(10:18:34 PM)</font> <b>wrl:</b></font> well<br/>
<font color="#A82F2F"><font size="2">(10:18:41 PM)</font> <b>fps:</b></font> which should always just be a few operations in the end..<br/>
<font color="#A82F2F"><font size="2">(10:18:50 PM)</font> <b>fps:</b></font> but i better shut up :) smarter people hve pondered this<br/>
<font color="#A82F2F"><font size="2">(10:18:56 PM)</font> <b>wrl:</b></font> this paper describes a way to do *all* the modification in the writer<br/>
<font color="#A82F2F"><font size="2">(10:19:03 PM)</font> <b>wrl:</b></font> i.e. the audio thread does nothing except read<br/>
<font color="#A82F2F"><font size="2">(10:19:39 PM)</font> <b>fps:</b></font> &quot;Linear scalability of read accesses&quot;<br/>
<font color="#A82F2F"><font size="2">(10:19:48 PM)</font> <b>fps:</b></font> hmm, what do they mean by that?<br/>
<font color="#A82F2F"><font size="2">(10:19:59 PM)</font> <b>fps:</b></font> ooh<br/>
<font color="#A82F2F"><font size="2">(10:20:03 PM)</font> <b>fps:</b></font> scalability wrt threads<br/>
<font color="#A82F2F"><font size="2">(10:20:05 PM)</font> <b>fps:</b></font> ok, got it<br/>
<font color="#A82F2F"><font size="2">(10:20:30 PM)</font> <b>fps:</b></font> i thought the lookup scaled linearly.. doh ;)<br/>
<font color="#A82F2F"><font size="2">(10:20:53 PM)</font> <b>fps:</b></font> wrl: anyways: that would be awesome! :)<br/>
<font color="#A82F2F"><font size="2">(10:21:22 PM)</font> <b>wrl:</b></font> will keep you updated<br/>
<font color="#A82F2F"><font size="2">(10:21:29 PM)</font> <b>fps:</b></font> ty<br/>
<font color="#A82F2F"><font size="2">(10:21:46 PM)</font> <b>fps:</b></font> or i&apos;ll just pester you againn after an appropriate delta_t<br/>
<font color="#A82F2F"><font size="2">(10:21:58 PM)</font> <b>wrl:</b></font> i think that RCU techniques, while perhaps overkill, could be a good solution for sharing data with a realtime thread<br/>
<font color="#A82F2F"><font size="2">(10:22:43 PM)</font> <b>fps:</b></font> i must admit that besides knowing that it stands for read copy update, i have no clue about rcu<br/>
<font color="#A82F2F"><font size="2">(10:23:00 PM)</font> <b>fps:</b></font> but i think i used similar things<br/>
<font color="#A82F2F"><font size="2">(10:23:14 PM)</font> <b>wrl:</b></font> it basically does what it says on the tin<br/>
<font color="#A82F2F"><font size="2">(10:23:51 PM)</font> <b>fps:</b></font> i.e. read from the non rt thread, copy it, modify it, then &quot;pointer&quot; swap the modified thing back in is something like it?<br/>
<font color="#A82F2F"><font size="2">(10:23:55 PM)</font> <b>wrl:</b></font> the gist is that you treat shared data structures as being semi-functional/immutable<br/>
<font color="#A82F2F"><font size="2">(10:23:56 PM)</font> <b>wrl:</b></font> yeah<br/>
<font color="#A82F2F"><font size="2">(10:23:56 PM)</font> <b>fps:</b></font> ok<br/>
<font color="#A82F2F"><font size="2">(10:23:56 PM)</font> <b>wrl:</b></font> but then RCU also involves knowing when the readers are done using the old thing<br/>
<font color="#A82F2F"><font size="2">(10:24:08 PM)</font> <b>wrl:</b></font> so that you can free the memory<br/>
<font color="#A82F2F"><font size="2">(10:24:20 PM)</font> <b>wrl:</b></font> and that&apos;s usually referred to as &quot;memory reclamation&quot;<br/>
<font color="#A82F2F"><font size="2">(10:24:24 PM)</font> <b>fps:</b></font> yes, i used shared_ptr&apos;s for that, keeping an extra reference around in the non - rt thread<br/>
<font color="#A82F2F"><font size="2">(10:24:33 PM)</font> <b>fps:</b></font> once count dropped to 1 i could free that last referece<br/>
<font color="#A82F2F"><font size="2">(10:24:36 PM)</font> <b>fps:</b></font> *reference<br/>
<font color="#A82F2F"><font size="2">(10:24:52 PM)</font> <b>wrl:</b></font> yeah<br/>
<font color="#A82F2F"><font size="2">(10:25:09 PM)</font> <b>wrl:</b></font> i&apos;m doing reference counting as well<br/>
<font color="#A82F2F"><font size="2">(10:25:33 PM)</font> <b>fps:</b></font> btw: was it you who did that awesome tune on that modern electroic music sampler?<br/>
<font color="#A82F2F"><font size="2">(10:25:40 PM)</font> <b>fps:</b></font> :)<br/>
<font color="#A82F2F"><font size="2">(10:25:42 PM)</font> <b>wrl:</b></font> i&apos;m not sure how shared_ptr works, but when i implemented it in C i found that it wasn&apos;t actually thread-safe<br/>
<font color="#A82F2F"><font size="2">(10:25:56 PM)</font> <b>fps:</b></font> i&apos;ve been away for quite a while :)<br/>
<font color="#A82F2F"><font size="2">(10:26:02 PM)</font> <b>wrl:</b></font> namely, that the operation of &quot;acquire a pointer, then increment the reference count&quot; is non-atomic<br/>
<font color="#A82F2F"><font size="2">(10:26:16 PM)</font> <b>fps:</b></font> hmmm<br/>
<font color="#A82F2F"><font size="2">(10:26:17 PM)</font> <b>wrl:</b></font> and the pointer could actually be freed between those two operations<br/>
<font color="#A82F2F"><font size="2">(10:26:22 PM)</font> <b>fps:</b></font> good poit<br/>
<font color="#A82F2F"><font size="2">(10:26:25 PM)</font> <b>fps:</b></font> damn my n key<br/>
<font color="#A82F2F"><font size="2">(10:26:45 PM)</font> <b>wrl:</b></font> it&apos;s a slim chance, but damn that would be a hard bug to find if it happened<br/>
<font color="#A82F2F"><font size="2">(10:26:56 PM)</font> <b>fps:</b></font> well, i basically did it this way: create new object in shared_ptr, reasultig in ref count 1. store another reference in a &quot;heap&quot;<br/>
<font color="#A82F2F"><font size="2">(10:27:22 PM)</font> <b>fps:</b></font> then copy the shared_ptr into the ringbuffer (which was populated by inplace new created shared_ptrs)<br/>
<font color="#A82F2F"><font size="2">(10:27:25 PM)</font> <b>wrl:</b></font> so i wrapped my reference counting with concurrencykit&apos;s epoch based reclamation, then realized that the audio thread doesn&apos;t even need to acquire a reference with it<br/>
<font color="#A82F2F"><font size="2">(10:27:28 PM)</font> <b>wrl:</b></font> ah yeah, nice<br/>
<font color="#A82F2F"><font size="2">(10:27:29 PM)</font> <b>fps:</b></font> increasing the refcount to 3, etc.. pp<br/>
<font color="#A82F2F"><font size="2">(10:27:49 PM)</font> <b>fps:</b></font> but you are right<br/>
<font color="#A82F2F"><font size="2">(10:27:54 PM)</font> <b>fps:</b></font> there might have been atomicity issues<br/>
<font color="#A82F2F"><font size="2">(10:27:57 PM)</font> <b>fundamental:</b></font> wrl: wouldn&apos;t it be sufficient to increment refcount, aquire valid flag, use pointer, decrement refcount?<br/>
<font color="#A82F2F"><font size="2">(10:28:07 PM)</font> <b>fps:</b></font> but i think i read about boost&apos;s shared_ptrs back then and deemed it safe<br/>
<font color="#A82F2F"><font size="2">(10:28:11 PM)</font> <b>wrl:</b></font> fundamental: the refcount would need to exist outside of the object in question<br/>
<font color="#A82F2F"><font size="2">(10:28:13 PM)</font> <b>fps:</b></font> but i might as well be wrong..<br/>
<font color="#A82F2F"><font size="2">(10:28:20 PM)</font> <b>xnor:</b></font> according to http://en.cppreference.com/w/cpp/memory/shared_ptr : &quot;To satisfy thread safety requirements, the reference counters are typically incremented and decremented using an equivalent of std::atomic::fetch_add with std::memory_order_relaxed. &quot;<br/>
<font color="#A82F2F"><font size="2">(10:28:21 PM)</font> <b>LAbot:</b></font> Title: std::shared_ptr - cppreference.com (at en.cppreference.com)<br/>
<font color="#A82F2F"><font size="2">(10:28:22 PM)</font> <b>wrl:</b></font> which is roughly how hazard pointers work<br/>
<font color="#A82F2F"><font size="2">(10:28:31 PM)</font> <b>wrl:</b></font> nah nah see here&apos;s the issue<br/>
<font color="#A82F2F"><font size="2">(10:28:45 PM)</font> <b>wrl:</b></font> struct *thing = global_struct-&gt;thing_ptr;<br/>
<font color="#A82F2F"><font size="2">(10:28:48 PM)</font> <b>wrl:</b></font> RETAIN(thing);<br/>
<font color="#A82F2F"><font size="2">(10:28:58 PM)</font> <b>fundamental:</b></font> wrl: yeah, if the whole thing is deleted, then you&apos;re out of luck<br/>
<font color="#A82F2F"><font size="2">(10:29:00 PM)</font> <b>wrl:</b></font> inbetween those two lines, the refcount could drop to 0 and `thing` could be freed<br/>
<font color="#A82F2F"><font size="2">(10:29:17 PM)</font> <b>wrl:</b></font> so the refcounting in this case would need to exist outside of `thing`<br/>
<font color="#A82F2F"><font size="2">(10:29:21 PM)</font> <b>wrl:</b></font> which again is roughly how hazard pointers work<br/>
<font color="#A82F2F"><font size="2">(10:29:25 PM)</font> <b>fundamental:</b></font> I was thinking that only the object stored by the shared pointer was destroyed, not the shared pointer itself<br/>
<font color="#A82F2F"><font size="2">(10:29:58 PM)</font> <b>wrl:</b></font> with hazard pointers, a thread can basically say &quot;hey, i&apos;m using this pointer&quot; before it acquires it<br/>
<font color="#A82F2F"><font size="2">(10:30:02 PM)</font> <b>wrl:</b></font> so you&apos;d do like<br/>
<font color="#A82F2F"><font size="2">(10:30:14 PM)</font> <b>wrl:</b></font> HAZARD_REF(global_struct-&gt;thing_ptr);<br/>
<font color="#A82F2F"><font size="2">(10:30:20 PM)</font> <b>wrl:</b></font> struct *thing = global_struct-&gt;thing_ptr;<br/>
<font color="#A82F2F"><font size="2">(10:30:26 PM)</font> <b>wrl:</b></font> /* stuff */<br/>
<font color="#A82F2F"><font size="2">(10:30:37 PM)</font> <b>wrl:</b></font> HAZARD_UNREF(thing);<br/>
<font color="#A82F2F"><font size="2">(10:32:41 PM)</font> <b>wrl:</b></font> there&apos;s a handful of different ways of solving this issue, hazard pointers are one<br/>
<font color="#A82F2F"><font size="2">(10:32:47 PM)</font> <b>wrl:</b></font> urcu has a few<br/>
<font color="#A82F2F"><font size="2">(10:32:58 PM)</font> <b>wrl:</b></font> i don&apos;t know 100% what the kernel uses but there&apos;s one in there too<br/>
